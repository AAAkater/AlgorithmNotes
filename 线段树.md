# 线段树

假设有编号从1到n的n个点，每个点都存了一些信息，用[L,R]表示下标从L到R的这些点。

线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是O(log2(n)).

线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。

由此看出，用线段树统计的东西，必须符合**区间加法**，否则，不可能通过分成的子区间来得到[L,R]的统计结果。

**符合区间加法的例子：**

数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和

最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );

最大值——总最大值=max(左区间最大值，右区间最大值)

**不符合区间加法的例子：**

众数——只知道左右区间的众数，没法求总区间的众数

01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零



### 线段树节点定义

```c++
struct node
{
    int l,r;
    int sum;
    int tag;
    //int add,mul;
    //多少种区间操作就在结构体加多少个标签

    //清空函数 初始化或者清理时可以用
    void clear()
    {
        tag=0;
        // mul=1;
        // add=0;
    }
}tree[N*4];// 线段树一般开4倍空间
int a[N];//原数组
```

### 建树

直接板子写

main里面写个build(1,1,n)    n为原数组长度

```cpp
void build(int p,int l,int r)
{
    tree[p].l=l;
    tree[p].r=r;
    //初始化标签
    tree[p].clear();
    if(l==r)//到了最下方的节点，此时节点直接对应数组
    {    
        tree[p].sum=a[l];
        return;
    }
    int mid=(l+r)/2;
    build(2*p,l,mid);
    build(2*p+1,mid+1,r);
    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;
    // 大区间的和为两个小区间的和之和c
}
```



### 下传懒标记

```c++
//给这个节点打标签 并更新tree
void addmark(int p,int d)
{
    tree[p].tag+=d;
    // 区间增加相同的数，即区间和增加 数字*数量
    tree[p].sum+=(tree[p].r-tree[p].l+1)*d;
}

void pushdown(int p)
{
    if(tree[p].tag)
    {
        // 懒标记往下传
        addmark(2*p,tree[p].tag);
        addmark(2*p+1,tree[p].tag);
        tree[p].tag=0;
    }
}
```

### 1.区间[l,r]都加上k
```cpp
void update(int p,int l,int r,int k)
{
    if(l<=tree[p].l&&tree[p].r<=r)
    {
        addmark(p,k);
        return;    
    }
    pushdown(p);
    int mid=(tree[p].l+tree[p].r)/2;
    if(l<=mid)
        update(2*p,l,r,k);
    if(mid+1<=r)
        update(2*p+1,l,r,k);
    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;
}
//询问(求区间[l,r]的和)
int query(int p,int l,int r)
{
    if(l<=tree[p].l&&tree[p].r<=r)
        return tree[p].sum;
    pushdown(p);
    int mid=(tree[p].l+tree[p].r)/2;
    int sum=0;
    if(mid>=l)
        sum+=query(2*p,l,r);
    if(mid+1<=r)
        sum+=query(2*p+1,l,r);
    return sum;
}
```

### 2.[l,r]区间开方
注意到同一个数连续开七次方就为1
```cpp
//这种没有tag标签
//[l,r]开方
void update(int p,int l,int r)
{
    if(tree[p].l==tree[p].r)
    {
        tree[p].sum=sqrt(tree[p].sum);
        return;
    }
    if(tree[p].sum<=tree[p].r-tree[p].l+1)
        return;
    //pushdown(p);
    int mid=(tree[p].l+tree[p].r)/2;
    if(l<=mid)
        update(2*p,l,r);
    if(mid+1<=r)
        update(2*p+1,l,r);
    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;
    return;
}
//查询[l,r]
int query(int p,int l,int r)
{
    if(l<=tree[p].l&&tree[p].r<=r)
        return tree[p].sum;
    // pushdown(p);
    int mid=(tree[p].l+tree[p].r)/2;
    int sum=0;
    if(mid>=l)
        sum+=query(2*p,l,r);
    if(mid+1<=r)
        sum+=query(2*p+1,l,r);
    return sum;
}
```

### 3.区间[l,r]都乘d或者加d

几种区间操作就添加几种tag
```cpp
struct node
{
    int l,r;
    int sum;
    int mul,add;
    void clear()
    {
        mul=1;
        add=0;
    }
}tree[N*4];
int a[N];
```

```cpp
void pushdown(int p)
{
    int l=tree[p].l,r=tree[p].r;
    int mid=(l+r)/2;
    //乘法优先
    tree[2*p].mul=(tree[2*p].mul*tree[p].mul)%MOD;
    tree[2*p+1].mul=(tree[2*p+1].mul*tree[p].mul)%MOD;

    tree[2*p].add=(tree[2*p].add*tree[p].mul+tree[p].add)%MOD;
    tree[2*p+1].add=(tree[2*p+1].add*tree[p].mul+tree[p].add)%MOD;

    tree[2*p].sum=(tree[2*p].sum*tree[p].mul+tree[p].add*(mid-l+1))%MOD;
    tree[2*p+1].sum=(tree[2*p+1].sum*tree[p].mul+tree[p].add*(r-mid))%MOD;
    //清空tag
    tree[p].clear();
    return;
}
```

update函数是分开写的
```cpp
void update_mul(int p,int l,int r,int d)
{
    if(l<=tree[p].l&&tree[p].r<=r)
    {
        tree[p].sum=(tree[p].sum*d)%MOD;
        tree[p].mul=(tree[p].mul*d)%MOD;
        tree[p].add=(tree[p].add*d)%MOD;
        return;
    }
    pushdown(p);
    int mid=(tree[p].l+tree[p].r)/2;
    if(l<=mid)
        update_mul(2*p,l,r,d);
    if(mid+1<=r)
        update_mul(2*p+1,l,r,d);
    tree[p].sum=(tree[2*p].sum+tree[2*p+1].sum)%MOD;
}
void update_add(int p,int l,int r,int d)
{
    if(l<=tree[p].l&&tree[p].r<=r)
    {
        tree[p].add=(tree[p].add+d)%MOD;
        tree[p].sum=(tree[p].sum+d*(tree[p].r-tree[p].l+1))%MOD;
        return;
    }
    pushdown(p);
    int mid=(tree[p].l+tree[p].r)/2;
    if(l<=mid)
        update_add(2*p,l,r,d);
    if(mid+1<=r)
        update_add(2*p+1,l,r,d);
    tree[p].sum=(tree[2*p].sum+tree[2*p+1].sum)%MOD;
}
```