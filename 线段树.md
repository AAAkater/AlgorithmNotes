# 线段树

假设有编号从1到n的n个点，每个点都存了一些信息，用[L,R]表示下标从L到R的这些点。

线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是O(log2(n)).

线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。

由此看出，用线段树统计的东西，必须符合**区间加法**，否则，不可能通过分成的子区间来得到[L,R]的统计结果。

**符合区间加法的例子：**

数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和

最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );

最大值——总最大值=max(左区间最大值，右区间最大值)

**不符合区间加法的例子：**

众数——只知道左右区间的众数，没法求总区间的众数

01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零



### 线段树节点定义

```c++
struct node
{
    int l;
    int r;
    int sum;
}tree[N*4];// 线段树一般开4倍空间
int a[N];//原数组
int mark[N*4];//懒标记
```

### 建树

直接板子写

main里面写个build(1,1,n)    n为原数组长度

```c++
void build(int p,int l,int r)
{
    tree[p].l=l;
    tree[p].r=r;
    if(l==r)//到了最下方的节点，此时节点直接对应数组
    {    
        tree[p].sum=a[l];
        return;
    }
    int mid=(l+r)/2;
    build(2*p,l,mid);
    build(2*p+1,mid+1,r);
    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;
    // 大区间的和为两个小区间的和之和c
}
```



### 下传懒标记

```c++
void pushdown(int p)
{
    if(mark[p])
    {
        int l=tree[p].l;
        int r=tree[p].r;
        int mid=(l+r)/2;
        // 懒标记往下传
        mark[p*2]+=mark[p];
        mark[p*2+1]+=mark[p];
        // 区间增加相同的数，即区间和增加 数字*数量
        tree[p*2].sum+=(mid-l+1)*mark[p];
        tree[p*2+1].sum+=(r-(mid+1)+1)*mark[p];
        //清除
        mark[p]=0;
    }
}
```



### 更新(区间[l,r]都加上k)

```c++
int update(int p,int l,int r,int k)
{
    if(l<=tree[p].l&&tree[p].r<=r)
    {
        tree[p].sum+=(tree[p].r-tree[p].l+1)*k;
        mark[p]+=k;
        return;    
    }
    pushdown(p);
    int mid=(tree[p].l+tree[p].r)/2;
    if(l<=mid)
        update(2*p,l,r,k);
    if(mid+1<=r)
        update(2*p+1,l,r,k);
    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;
}
```



### 询问(求区间[l,r]的和)

```c++
int query(int p,int l,int r)
{
    if(l<=tree[p].l&&tree[p].r<=r)
        return tree[p].sum;
    pushdown(p);
    int mid(tree[p].l+tree[p],r)/2;
    int sum=0;
    if(mid>=l)
        sum+=query(2*p,l,r);
    if(mid+1<=r)
        sum+=query(2*p+1,l,r);
    return sum;
}
```

