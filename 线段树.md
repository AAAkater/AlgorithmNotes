# 线段树

假设有编号从1到n的n个点，每个点都存了一些信息，用[L,R]表示下标从L到R的这些点。

线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是$O(log2(n))$.

线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。

由此看出，用线段树统计的东西，必须符合**区间加法**，否则，不可能通过分成的子区间来得到[L,R]的统计结果。

**符合区间加法的例子：**

数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和

最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );

最大值——总最大值=max(左区间最大值，右区间最大值)

**不符合区间加法的例子：**

众数——只知道左右区间的众数，没法求总区间的众数

01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零



### 线段树节点定义

```c++
struct node
{
    int l,r;
    int sum;
    int tag;
    //int add,mul;
    //多少种区间操作就在结构体加多少个标签

    //清空函数 初始化或者清理时可以用
    void clear()
    {
        tag=0;
        // mul=1;
        // add=0;
    }
}tree[N*4];// 线段树一般开4倍空间
int a[N];//原数组
```

### 线段树的函数
这三个函数大部分内容一样
1. ``build(int p,int l,int r)``建树
2. ``update(int p,int l,int r,int k)``更新区间[l,r]
3. ``query(int p,int l,int r)``询问[l,r]

主要这三个函数因题意变换 后面板子都只写这几个
1. ``addtag(int p,int d)``给节点p添加标签
2. ``pushdown(int p)``下传节点p的标签(线段树核心代码)
3. ``pushup(int p)``
```cpp
//main里面写个build(1,1,n)    n为原数组长度
void build(int p,int l,int r)
{
    tree[p].l=l;
    tree[p].r=r;
    tree[p].clear();//初始化标签
    if(l==r)//到了最下方的节点，此时节点直接对应数组
    {    
        tree[p].sum=a[l];
        return;
    }
    int mid=(l+r)/2;
    build(2*p,l,mid);
    build(2*p+1,mid+1,r);
    pushup(p);// 大区间的和为两个小区间的和之和c
}
//更新区间[l,r] 一般几种区间操作就写几种update函数
void update(int p,int l,int r,int k)
{
    if(l<=tree[p].l&&tree[p].r<=r)
    {
        //给p节点打上标签
        addtag(p,k);
        return;    
    }
    //下传节点p的标签
    pushdown(p);
    int mid=(tree[p].l+tree[p].r)/2;
    if(l<=mid)
        update(2*p,l,r,k);
    if(mid+1<=r)
        update(2*p+1,l,r,k);
    pushup(p);
}
//询问区间[l,r]
int query(int p,int l,int r)
{
    if(l<=tree[p].l&&tree[p].r<=r)
        return tree[p].sum;
    pushdown(p);
    int mid=(tree[p].l+tree[p].r)/2;
    int sum=0;
    if(mid>=l)
        sum+=query(2*p,l,r);
    if(mid+1<=r)
        sum+=query(2*p+1,l,r);
    return sum;
}
```
------
### 1.区间[l,r]都加上k

```c++
//给这个节点打标签 并更新tree
void addtag(int p,int d)
{
    tree[p].tag+=d;
    // 区间增加相同的数，即区间和增加 数字*数量
    tree[p].sum+=(tree[p].r-tree[p].l+1)*d;
}
void pushup(int p)
{
    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;
}
void pushdown(int p)
{
    if(tree[p].tag)
    {
        // 懒标记往下传
        addtag(2*p,tree[p].tag);
        addtag(2*p+1,tree[p].tag);
        tree[p].clear();
    }
}
```

### 2.[l,r]区间开方
注意到同一个数连续开七次方就为1
```cpp
//这种没有tag标签
//[l,r]开方
void update(int p,int l,int r)
{
    if(tree[p].l==tree[p].r)
    {
        tree[p].sum=sqrt(tree[p].sum);
        return;
    }
    //核心代码 区间和等于区间长度说明全是1 不需要更新了
    if(tree[p].sum<=tree[p].r-tree[p].l+1)
        return;
    int mid=(tree[p].l+tree[p].r)/2;
    if(l<=mid)
        update(2*p,l,r);
    if(mid+1<=r)
        update(2*p+1,l,r);
    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;
    return;
}
//查询[l,r]跟上面query函数一样的
```
### 3.区间[l,r]都乘d或者加d

几种区间操作就添加几种tag
```cpp
struct node
{
    int l,r;
    int sum;
    int mul,add;
    void clear()
    {
        mul=1;
        add=0;
    }
}tree[N*4];
int a[N];
void pushdown(int p)
{
    int l=tree[p].l,r=tree[p].r;
    int mid=(l+r)/2;
    //乘法优先
    //下传乘标签
    tree[2*p].mul=(tree[2*p].mul*tree[p].mul)%MOD;
    tree[2*p+1].mul=(tree[2*p+1].mul*tree[p].mul)%MOD;
    //下传加标签
    tree[2*p].add=(tree[2*p].add*tree[p].mul+tree[p].add)%MOD;
    tree[2*p+1].add=(tree[2*p+1].add*tree[p].mul+tree[p].add)%MOD;

    tree[2*p].sum=(tree[2*p].sum*tree[p].mul+tree[p].add*(mid-l+1))%MOD;
    tree[2*p+1].sum=(tree[2*p+1].sum*tree[p].mul+tree[p].add*(r-mid))%MOD;
    //清空tag
    tree[p].clear();
    return;
}
//区间都乘d 打此区间的标签
void addtag_mul(int p,int d)
{
    tree[p].sum=(tree[p].sum*d)%MOD;
    tree[p].mul=(tree[p].mul*d)%MOD;
    tree[p].add=(tree[p].add*d)%MOD;
}
//区间都加d 打此区间的标签
void addtag_add(int p,int d)
{
    tree[p].add=(tree[p].add+d)%MOD;
    tree[p].sum=(tree[p].sum+d*(tree[p].r-tree[p].l+1))%MOD;
}
```

